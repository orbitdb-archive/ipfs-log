var Log;(()=>{var e={136:e=>{e.exports={space:"",cycles:!1,replacer:(e,t)=>t,stringify:JSON.stringify}},299:(e,t,r)=>{"use strict";const n=r(136),o=r(572).isFunction,i=r(572).isBoolean,s=r(572).isObject,a=r(572).isArray,c=r(572).isRegex,u=r(572).assign,h=r(572).keys;e.exports=function(e,t){t=t||u({},n),o(t)&&(t={compare:t});const r=t.space||n.space,l=i(t.cycles)?t.cycles:n.cycles,f=t.replacer||n.replacer,d=t.stringify||n.stringify,y=t.compare&&(p=t.compare,function(e){return function(t,r){const n={key:t,value:e[t]},o={key:r,value:e[r]};return p(n,o)}});var p;l||d(e);const w=[];return function e(t,n,o,i){const u=r?"\n"+new Array(i+1).join(r):"",p=r?": ":":";if(o=function(e){return null==e?e:c(e)?e.toString():e.toJSON?e.toJSON():e}(o),void 0!==(o=f.call(t,n,o))){if(!s(o)||null===o)return d(o);if(a(o)){const t=[];for(let n=0;n<o.length;n++){const s=e(o,n,o[n],i+1)||d(null);t.push(u+r+s)}return"["+t.join(",")+u+"]"}{if(l){if(-1!==w.indexOf(o))return d("[Circular]");w.push(o)}const t=h(o).sort(y&&y(o)),n=[];for(let s=0;s<t.length;s++){const a=t[s],c=e(o,a,o[a],i+1);if(!c)continue;const h=d(a)+p+c;n.push(u+r+h)}return w.splice(w.indexOf(o),1),"{"+n.join(",")+u+"}"}}}({"":e},"",e,0)}},572:e=>{"use strict";e.exports={isArray:Array.isArray,assign:Object.assign,isObject:e=>"object"==typeof e,isFunction:e=>"function"==typeof e,isBoolean:e=>"boolean"==typeof e,isRegex:e=>e instanceof RegExp,keys:Object.keys}},696:()=>{}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var i=t[n]={exports:{}};return e[n](i,i.exports,r),i.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};(()=>{"use strict";r.r(n),r.d(n,{AccessController:()=>Zr,Entry:()=>Cr,IPLD_LINKS:()=>kr,Sorting:()=>Or,default:()=>an,getWriteFormat:()=>Ar});var e={};r.r(e),r.d(e,{code:()=>Be,createLink:()=>De,createNode:()=>je,decode:()=>Pe,encode:()=>$e,name:()=>Se,prepare:()=>Te,validate:()=>Ne});var t={};r.r(t),r.d(t,{code:()=>sr,decode:()=>cr,encode:()=>ar,name:()=>ir});var o=r(696);const i=/\s+at.*[(\s](.*)\)?/,s=/^(?:(?:(?:node|node:[\w/]+|(?:(?:node:)?internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)(?:\.js)?:\d+:\d+)|native)/,a=void 0===o.homedir?"":o.homedir().replace(/\\/g,"/");class c extends Error{#e;name="AggregateError";constructor(e){if(!Array.isArray(e))throw new TypeError("Expected input to be an Array, got "+typeof e);let t=(e=e.map((e=>e instanceof Error?e:null!==e&&"object"==typeof e?Object.assign(new Error(e.message),e):new Error(e)))).map((e=>"string"==typeof e.stack&&e.stack.length>0?function(e,{pretty:t=!1,basePath:r}={}){const n=r&&new RegExp(`(at | \\()${function(e){if("string"!=typeof e)throw new TypeError("Expected a string");return e.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}(r.replace(/\\/g,"/"))}`,"g");if("string"==typeof e)return e.replace(/\\/g,"/").split("\n").filter((e=>{const t=e.match(i);if(null===t||!t[1])return!0;const r=t[1];return!(r.includes(".app/Contents/Resources/electron.asar")||r.includes(".app/Contents/Resources/default_app.asar")||r.includes("node_modules/electron/dist/resources/electron.asar")||r.includes("node_modules/electron/dist/resources/default_app.asar")||s.test(r))})).filter((e=>""!==e.trim())).map((e=>(n&&(e=e.replace(n,"$1")),t&&(e=e.replace(i,((e,t)=>e.replace(t,t.replace(a,"~"))))),e))).join("\n")}(e.stack).replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g,""):String(e))).join("\n");t="\n"+function(e,t=1,r={}){const{indent:n=" ",includeEmptyLines:o=!1}=r;if("string"!=typeof e)throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if("number"!=typeof t)throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);if(t<0)throw new RangeError(`Expected \`count\` to be at least 0, got \`${t}\``);if("string"!=typeof n)throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof n}\``);if(0===t)return e;const i=o?/^/gm:/^(?!\s*$)/gm;return e.replace(i,n.repeat(t))}(t,4),super(t),this.#e=e}get errors(){return this.#e.slice()}}class u extends Error{constructor(e){super(),this.name="AbortError",this.message=e}}const h=e=>void 0===globalThis.DOMException?new u(e):new DOMException(e),l=e=>{const t=void 0===e.reason?h("This operation was aborted."):e.reason;return t instanceof Error?t:h(t)};async function f(e,t,{concurrency:r=Number.POSITIVE_INFINITY,stopOnError:n=!0,signal:o}={}){return new Promise(((i,s)=>{if(void 0===e[Symbol.iterator]&&void 0===e[Symbol.asyncIterator])throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof e})`);if("function"!=typeof t)throw new TypeError("Mapper function is required");if(!Number.isSafeInteger(r)&&r!==Number.POSITIVE_INFINITY||!(r>=1))throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${r}\` (${typeof r})`);const a=[],u=[],h=new Map;let f=!1,y=!1,p=!1,w=0,g=0;const b=void 0===e[Symbol.iterator]?e[Symbol.asyncIterator]():e[Symbol.iterator](),m=e=>{f=!0,y=!0,s(e)};o&&(o.aborted&&m(l(o)),o.addEventListener("abort",(()=>{m(l(o))})));const v=async()=>{if(y)return;const e=await b.next(),r=g;if(g++,e.done){if(p=!0,0===w&&!y){if(!n&&u.length>0)return void m(new c(u));if(y=!0,0===h.size)return void i(a);const e=[];for(const[t,r]of a.entries())h.get(t)!==d&&e.push(r);i(e)}}else w++,(async()=>{try{const n=await e.value;if(y)return;const o=await t(n,r);o===d&&h.set(r,o),a[r]=o,w--,await v()}catch(e){if(n)m(e);else{u.push(e),w--;try{await v()}catch(e){m(e)}}}})()};(async()=>{for(let e=0;e<r;e++){try{await v()}catch(e){m(e);break}if(p||f)break}})()}))}const d=Symbol("skip"),y=class{constructor(e){}append(e){}merge(e){}get(e){}has(e){}get values(){}get length(){}};class p{constructor(e,t){this.id=e,this.time=t||0}tick(){return new p(this.id,++this.time)}merge(e){return this.time=Math.max(this.time,e.time),new p(this.id,this.time)}clone(){return new p(this.id,this.time)}static compare(e,t){const r=e.time-t.time;return 0===r&&e.id!==t.id?e.id<t.id?-1:1:r}}const w=p;var g=Math.pow(2,31),b=Math.pow(2,7),m=Math.pow(2,14),v=Math.pow(2,21),E=Math.pow(2,28),k=Math.pow(2,35),x=Math.pow(2,42),A=Math.pow(2,49),I=Math.pow(2,56),C=Math.pow(2,63);const T={encode:function e(t,r,n){r=r||[];for(var o=n=n||0;t>=g;)r[n++]=255&t|128,t/=128;for(;-128&t;)r[n++]=255&t|128,t>>>=7;return r[n]=0|t,e.bytes=n-o+1,r},decode:function e(t,r){var n,o=0,i=0,s=r=r||0,a=t.length;do{if(s>=a)throw e.bytes=0,new RangeError("Could not decode varint");n=t[s++],o+=i<28?(127&n)<<i:(127&n)*Math.pow(2,i),i+=7}while(n>=128);return e.bytes=s-r,o},encodingLength:function(e){return e<b?1:e<m?2:e<v?3:e<E?4:e<k?5:e<x?6:e<A?7:e<I?8:e<C?9:10}},N=(e,t=0)=>[T.decode(e,t),T.decode.bytes],j=(e,t,r=0)=>(T.encode(e,t,r),t),D=e=>T.encodingLength(e),S=(new Uint8Array(0),e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}),B=(e,t)=>{const r=t.byteLength,n=D(e),o=n+D(r),i=new Uint8Array(o+r);return j(e,i,0),j(r,i,n),i.set(t,o),new $(e,r,t,i)};class ${constructor(e,t,r,n){this.code=e,this.size=t,this.digest=r,this.bytes=n}}const P=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<e.length;o++){var i=e.charAt(o),s=i.charCodeAt(0);if(255!==r[s])throw new TypeError(i+" is ambiguous");r[s]=o}var a=e.length,c=e.charAt(0),u=Math.log(a)/Math.log(256),h=Math.log(256)/Math.log(a);function l(e){if("string"!=typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var n=0,o=0;e[t]===c;)n++,t++;for(var i=(e.length-t)*u+1>>>0,s=new Uint8Array(i);e[t];){var h=r[e.charCodeAt(t)];if(255===h)return;for(var l=0,f=i-1;(0!==h||l<o)&&-1!==f;f--,l++)h+=a*s[f]>>>0,s[f]=h%256>>>0,h=h/256>>>0;if(0!==h)throw new Error("Non-zero carry");o=l,t++}if(" "!==e[t]){for(var d=i-o;d!==i&&0===s[d];)d++;for(var y=new Uint8Array(n+(i-d)),p=n;d!==i;)y[p++]=s[d++];return y}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var r=0,n=0,o=0,i=t.length;o!==i&&0===t[o];)o++,r++;for(var s=(i-o)*h+1>>>0,u=new Uint8Array(s);o!==i;){for(var l=t[o],f=0,d=s-1;(0!==l||f<n)&&-1!==d;d--,f++)l+=256*u[d]>>>0,u[d]=l%a>>>0,l=l/a>>>0;if(0!==l)throw new Error("Non-zero carry");n=f,o++}for(var y=s-n;y!==s&&0===u[y];)y++;for(var p=c.repeat(r);y<s;++y)p+=e.charAt(u[y]);return p},decodeUnsafe:l,decode:function(e){var r=l(e);if(r)return r;throw new Error(`Non-${t} character`)}}};class O{constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class _{constructor(e,t,r){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=r}decode(e){if("string"==typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return L(this,e)}}class U{constructor(e){this.decoders=e}or(e){return L(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const L=(e,t)=>new U({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class M{constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new O(e,t,r),this.decoder=new _(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const z=({name:e,prefix:t,encode:r,decode:n})=>new M(e,t,r,n),H=({prefix:e,name:t,alphabet:r})=>{const{encode:n,decode:o}=P(r,t);return z({prefix:e,name:t,encode:n,decode:e=>S(o(e))})},F=({name:e,prefix:t,bitsPerChar:r,alphabet:n})=>z({prefix:t,name:e,encode:e=>((e,t,r)=>{const n="="===t[t.length-1],o=(1<<r)-1;let i="",s=0,a=0;for(let n=0;n<e.length;++n)for(a=a<<8|e[n],s+=8;s>r;)s-=r,i+=t[o&a>>s];if(s&&(i+=t[o&a<<r-s]),n)for(;i.length*r&7;)i+="=";return i})(e,n,r),decode:t=>((e,t,r,n)=>{const o={};for(let e=0;e<t.length;++e)o[t[e]]=e;let i=e.length;for(;"="===e[i-1];)--i;const s=new Uint8Array(i*r/8|0);let a=0,c=0,u=0;for(let t=0;t<i;++t){const i=o[e[t]];if(void 0===i)throw new SyntaxError(`Non-${n} character`);c=c<<r|i,a+=r,a>=8&&(a-=8,s[u++]=255&c>>a)}if(a>=r||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s})(t,n,r,e)}),R=H({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),G=(H({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),F({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}));F({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),F({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),F({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),F({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),F({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),F({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),F({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),F({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});class V{constructor(e,t,r,n){this.code=t,this.version=e,this.multihash=r,this.bytes=n,this.byteOffset=n.byteOffset,this.byteLength=n.byteLength,this.asCID=this,this._baseCache=new Map,Object.defineProperties(this,{byteOffset:ee,byteLength:ee,code:X,version:X,multihash:X,bytes:X,_baseCache:ee,asCID:ee})}toV0(){if(0===this.version)return this;{const{code:e,multihash:t}=this;if(e!==K)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==Z)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return V.createV0(t)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=B(e,t);return V.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}equals(e){return e&&this.code===e.code&&this.version===e.version&&((t=this.multihash)===(r=e.multihash)||t.code===r.code&&t.size===r.size&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0})(t.bytes,r.bytes));var t,r}toString(e){const{bytes:t,version:r,_baseCache:n}=this;return 0===r?J(t,n,e||R.encoder):W(t,n,e||G.encoder)}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID("+this.toString()+")"}static isCID(e){return te(/^0\.0/,re),!(!e||!e[Y]&&e.asCID!==e)}get toBaseEncodedString(){throw new Error("Deprecated, use .toString()")}get codec(){throw new Error('"codec" property is deprecated, use integer "code" property instead')}get buffer(){throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")}get multibaseName(){throw new Error('"multibaseName" property is deprecated')}get prefix(){throw new Error('"prefix" property is deprecated')}static asCID(e){if(e instanceof V)return e;if(null!=e&&e.asCID===e){const{version:t,code:r,multihash:n,bytes:o}=e;return new V(t,r,n,o||Q(t,r,n.bytes))}if(null!=e&&!0===e[Y]){const{version:t,multihash:r,code:n}=e,o=(e=>{const t=S(e),[r,n]=N(t),[o,i]=N(t.subarray(n)),s=t.subarray(n+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new $(r,o,s,t)})(r);return V.create(t,n,o)}return null}static create(e,t,r){if("number"!=typeof t)throw new Error("String codecs are no longer supported");switch(e){case 0:if(t!==K)throw new Error(`Version 0 CID must use dag-pb (code: ${K}) block encoding`);return new V(e,t,r,r.bytes);case 1:{const n=Q(e,t,r.bytes);return new V(e,t,r,n)}default:throw new Error("Invalid version")}}static createV0(e){return V.create(0,K,e)}static createV1(e,t){return V.create(1,e,t)}static decode(e){const[t,r]=V.decodeFirst(e);if(r.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=V.inspectBytes(e),r=t.size-t.multihashSize,n=S(e.subarray(r,r+t.multihashSize));if(n.byteLength!==t.multihashSize)throw new Error("Incorrect length");const o=n.subarray(t.multihashSize-t.digestSize),i=new $(t.multihashCode,t.digestSize,o,n);return[0===t.version?V.createV0(i):V.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[r,n]=N(e.subarray(t));return t+=n,r};let n=r(),o=K;if(18===n?(n=0,t=0):1===n&&(o=r()),0!==n&&1!==n)throw new RangeError(`Invalid CID version ${n}`);const i=t,s=r(),a=r(),c=t+a;return{version:n,codec:o,multihashCode:s,digestSize:a,multihashSize:c-i,size:c}}static parse(e,t){const[r,n]=q(e,t),o=V.decode(n);return o._baseCache.set(r,e),o}}const q=(e,t)=>{switch(e[0]){case"Q":{const r=t||R;return[R.prefix,r.decode(`${R.prefix}${e}`)]}case R.prefix:{const r=t||R;return[R.prefix,r.decode(e)]}case G.prefix:{const r=t||G;return[G.prefix,r.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},J=(e,t,r)=>{const{prefix:n}=r;if(n!==R.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=t.get(n);if(null==o){const o=r.encode(e).slice(1);return t.set(n,o),o}return o},W=(e,t,r)=>{const{prefix:n}=r,o=t.get(n);if(null==o){const o=r.encode(e);return t.set(n,o),o}return o},K=112,Z=18,Q=(e,t,r)=>{const n=D(e),o=n+D(t),i=new Uint8Array(o+r.byteLength);return j(e,i,0),j(t,i,n),i.set(r,o),i},Y=Symbol.for("@ipld/js-cid/CID"),X={writable:!1,configurable:!1,enumerable:!0},ee={writable:!1,enumerable:!1,configurable:!1},te=(e,t)=>{if(!e.test("0.0.0-dev"))throw new Error(t);console.warn(t)},re="CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n",ne=({name:e,code:t,encode:r})=>new oe(e,t,r);class oe{constructor(e,t,r){this.name=e,this.code=t,this.encode=r}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?B(this.code,t):t.then((e=>B(this.code,e)))}throw Error("Unknown type, must be binary type")}}const ie=({enumerable:e=!0,configurable:t=!1}={})=>({enumerable:e,configurable:t,writable:!1}),se=function*(e,t){if(null!=e&&!(e instanceof Uint8Array))for(const[r,n]of Object.entries(e)){const e=[...t,r];if(null!=n&&"object"==typeof n)if(Array.isArray(n))for(const[t,r]of n.entries()){const n=[...e,t],o=V.asCID(r);o?yield[n.join("/"),o]:"object"==typeof r&&(yield*se(r,n))}else{const t=V.asCID(n);t?yield[e.join("/"),t]:yield*se(n,e)}}},ae=function*(e,t){if(null!=e)for(const[r,n]of Object.entries(e)){const e=[...t,r];if(yield e.join("/"),!(null==n||n instanceof Uint8Array||"object"!=typeof n||V.asCID(n)))if(Array.isArray(n))for(const[t,r]of n.entries()){const n=[...e,t];yield n.join("/"),"object"!=typeof r||V.asCID(r)||(yield*ae(r,n))}else yield*ae(n,e)}};class ce{constructor({cid:e,bytes:t,value:r}){if(!e||!t||void 0===r)throw new Error("Missing required argument");this.cid=e,this.bytes=t,this.value=r,this.asBlock=this,Object.defineProperties(this,{cid:ie(),bytes:ie(),value:ie(),asBlock:ie()})}links(){return se(this.value,[])}tree(){return ae(this.value,[])}get(e="/"){return((e,t)=>{let r=e;for(const[e,n]of t.entries()){if(r=r[n],null==r)throw new Error(`Object has no property at ${t.slice(0,e+1).map((e=>`[${JSON.stringify(e)}]`)).join("")}`);const o=V.asCID(r);if(o)return{value:o,remaining:t.slice(e+1).join("/")}}return{value:r}})(this.value,e.split("/").filter(Boolean))}}const ue=new TextDecoder;function he(e,t){let r=0;for(let n=0;;n+=7){if(n>=64)throw new Error("protobuf: varint overflow");if(t>=e.length)throw new Error("protobuf: unexpected end of data");const o=e[t++];if(r+=n<28?(127&o)<<n:(127&o)*2**n,o<128)break}return[r,t]}function le(e,t){let r;[r,t]=he(e,t);const n=t+r;if(r<0||n<0)throw new Error("protobuf: invalid length");if(n>e.length)throw new Error("protobuf: unexpected end of data");return[e.subarray(t,n),n]}function fe(e,t){let r;return[r,t]=he(e,t),[7&r,r>>3,t]}function de(e){const t={},r=e.length;let n=0;for(;n<r;){let r,o;if([r,o,n]=fe(e,n),1===o){if(t.Hash)throw new Error("protobuf: (PBLink) duplicate Hash section");if(2!==r)throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Hash`);if(void 0!==t.Name)throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[t.Hash,n]=le(e,n)}else if(2===o){if(void 0!==t.Name)throw new Error("protobuf: (PBLink) duplicate Name section");if(2!==r)throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Name`);if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");let o;[o,n]=le(e,n),t.Name=ue.decode(o)}else{if(3!==o)throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${o}`);if(void 0!==t.Tsize)throw new Error("protobuf: (PBLink) duplicate Tsize section");if(0!==r)throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Tsize`);[t.Tsize,n]=he(e,n)}}if(n>r)throw new Error("protobuf: (PBLink) unexpected end of data");return t}const ye=new TextEncoder,pe=2**32;function we(e,t){let r=t.length;if("number"==typeof e.Tsize){if(e.Tsize<0)throw new Error("Tsize cannot be negative");if(!Number.isSafeInteger(e.Tsize))throw new Error("Tsize too large for encoding");r=be(t,r,e.Tsize)-1,t[r]=24}if("string"==typeof e.Name){const n=ye.encode(e.Name);r-=n.length,t.set(n,r),r=be(t,r,n.length)-1,t[r]=18}return e.Hash&&(r-=e.Hash.length,t.set(e.Hash,r),r=be(t,r,e.Hash.length)-1,t[r]=10),t.length-r}function ge(e){let t=0;if(e.Hash){const r=e.Hash.length;t+=1+r+me(r)}if("string"==typeof e.Name){const r=ye.encode(e.Name).length;t+=1+r+me(r)}return"number"==typeof e.Tsize&&(t+=1+me(e.Tsize)),t}function be(e,t,r){const n=t-=me(r);for(;r>=2147483648;)e[t++]=127&r|128,r/=128;for(;r>=128;)e[t++]=127&r|128,r>>>=7;return e[t]=r,n}function me(e){return e%2==0&&e++,Math.floor((function(e){let t=0;return e>=pe&&(e=Math.floor(e/pe),t=32),e>=65536&&(e>>>=16,t+=16),e>=256&&(e>>>=8,t+=8),t+ve[e]}(e)+6)/7)}const ve=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],Ee=["Data","Links"],ke=["Hash","Name","Tsize"],xe=new TextEncoder;function Ae(e,t){if(e===t)return 0;const r=e.Name?xe.encode(e.Name):[],n=t.Name?xe.encode(t.Name):[];let o=r.length,i=n.length;for(let e=0,t=Math.min(o,i);e<t;++e)if(r[e]!==n[e]){o=r[e],i=n[e];break}return o<i?-1:i<o?1:0}function Ie(e,t){return!Object.keys(e).some((e=>!t.includes(e)))}function Ce(e){if("object"==typeof e.asCID){const t=V.asCID(e);if(!t)throw new TypeError("Invalid DAG-PB form");return{Hash:t}}if("object"!=typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");const t={};if(e.Hash){let r=V.asCID(e.Hash);try{r||("string"==typeof e.Hash?r=V.parse(e.Hash):e.Hash instanceof Uint8Array&&(r=V.decode(e.Hash)))}catch(e){throw new TypeError(`Invalid DAG-PB form: ${e.message}`)}r&&(t.Hash=r)}if(!t.Hash)throw new TypeError("Invalid DAG-PB form");return"string"==typeof e.Name&&(t.Name=e.Name),"number"==typeof e.Tsize&&(t.Tsize=e.Tsize),t}function Te(e){if((e instanceof Uint8Array||"string"==typeof e)&&(e={Data:e}),"object"!=typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");const t={};if(void 0!==e.Data)if("string"==typeof e.Data)t.Data=xe.encode(e.Data);else{if(!(e.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form");t.Data=e.Data}if(void 0!==e.Links){if(!Array.isArray(e.Links))throw new TypeError("Invalid DAG-PB form");t.Links=e.Links.map(Ce),t.Links.sort(Ae)}else t.Links=[];return t}function Ne(e){if(!e||"object"!=typeof e||Array.isArray(e))throw new TypeError("Invalid DAG-PB form");if(!Ie(e,Ee))throw new TypeError("Invalid DAG-PB form (extraneous properties)");if(void 0!==e.Data&&!(e.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");if(!Array.isArray(e.Links))throw new TypeError("Invalid DAG-PB form (Links must be an array)");for(let t=0;t<e.Links.length;t++){const r=e.Links[t];if(!r||"object"!=typeof r||Array.isArray(r))throw new TypeError("Invalid DAG-PB form (bad link object)");if(!Ie(r,ke))throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");if(!r.Hash)throw new TypeError("Invalid DAG-PB form (link must have a Hash)");if(r.Hash.asCID!==r.Hash)throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(void 0!==r.Name&&"string"!=typeof r.Name)throw new TypeError("Invalid DAG-PB form (link Name must be a string)");if(void 0!==r.Tsize&&("number"!=typeof r.Tsize||r.Tsize%1!=0))throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(t>0&&-1===Ae(r,e.Links[t-1]))throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}function je(e,t=[]){return Te({Data:e,Links:t})}function De(e,t,r){return Ce({Hash:r,Name:e,Tsize:t})}const Se="dag-pb",Be=112;function $e(e){Ne(e);const t={};return e.Links&&(t.Links=e.Links.map((e=>{const t={};return e.Hash&&(t.Hash=e.Hash.bytes),void 0!==e.Name&&(t.Name=e.Name),void 0!==e.Tsize&&(t.Tsize=e.Tsize),t}))),e.Data&&(t.Data=e.Data),function(e){const t=function(e){let t=0;if(e.Data){const r=e.Data.length;t+=1+r+me(r)}if(e.Links)for(const r of e.Links){const e=ge(r);t+=1+e+me(e)}return t}(e),r=new Uint8Array(t);let n=t;if(e.Data&&(n-=e.Data.length,r.set(e.Data,n),n=be(r,n,e.Data.length)-1,r[n]=10),e.Links)for(let t=e.Links.length-1;t>=0;t--){const o=we(e.Links[t],r.subarray(0,n));n-=o,n=be(r,n,o)-1,r[n]=18}return r}(t)}function Pe(e){const t=function(e){const t=e.length;let r,n,o=0,i=!1;for(;o<t;){let t,s;if([t,s,o]=fe(e,o),2!==t)throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${t}`);if(1===s){if(n)throw new Error("protobuf: (PBNode) duplicate Data section");[n,o]=le(e,o),r&&(i=!0)}else{if(2!==s)throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${s}`);{if(i)throw new Error("protobuf: (PBNode) duplicate Links section");let t;r||(r=[]),[t,o]=le(e,o),r.push(de(t))}}}if(o>t)throw new Error("protobuf: (PBNode) unexpected end of data");const s={};return n&&(s.Data=n),s.Links=r||[],s}(e),r={};return t.Data&&(r.Data=t.Data),t.Links&&(r.Links=t.Links.map((e=>{const t={};try{t.Hash=V.decode(e.Hash)}catch(e){}if(!t.Hash)throw new Error("Invalid Hash field found in link, expected CID");return void 0!==e.Name&&(t.Name=e.Name),void 0!==e.Tsize&&(t.Tsize=e.Tsize),t}))),r}const Oe=["string","number","bigint","symbol"],_e=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];class Ue{constructor(e,t,r){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}Ue.uint=new Ue(0,"uint",!0),Ue.negint=new Ue(1,"negint",!0),Ue.bytes=new Ue(2,"bytes",!0),Ue.string=new Ue(3,"string",!0),Ue.array=new Ue(4,"array",!1),Ue.map=new Ue(5,"map",!1),Ue.tag=new Ue(6,"tag",!1),Ue.float=new Ue(7,"float",!0),Ue.false=new Ue(7,"false",!0),Ue.true=new Ue(7,"true",!0),Ue.null=new Ue(7,"null",!0),Ue.undefined=new Ue(7,"undefined",!0),Ue.break=new Ue(7,"break",!0);class Le{constructor(e,t,r){this.type=e,this.value=t,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const Me=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"==typeof globalThis.Buffer.isBuffer,ze=new TextDecoder,He=new TextEncoder;function Fe(e){return Me&&globalThis.Buffer.isBuffer(e)}function Re(e){return e instanceof Uint8Array?Fe(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e:Uint8Array.from(e)}const Ge=Me?(e,t,r)=>r-t>64?globalThis.Buffer.from(e.subarray(t,r)).toString("utf8"):Qe(e,t,r):(e,t,r)=>r-t>64?ze.decode(e.subarray(t,r)):Qe(e,t,r),Ve=Me?e=>e.length>64?globalThis.Buffer.from(e):Ze(e):e=>e.length>64?He.encode(e):Ze(e),qe=e=>Uint8Array.from(e),Je=Me?(e,t,r)=>Fe(e)?new Uint8Array(e.subarray(t,r)):e.slice(t,r):(e,t,r)=>e.slice(t,r),We=Me?(e,t)=>(e=e.map((e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e))),Re(globalThis.Buffer.concat(e,t))):(e,t)=>{const r=new Uint8Array(t);let n=0;for(let t of e)n+t.length>r.length&&(t=t.subarray(0,r.length-n)),r.set(t,n),n+=t.length;return r},Ke=Me?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function Ze(e,t=1/0){let r;const n=e.length;let o=null;const i=[];for(let s=0;s<n;++s){if(r=e.charCodeAt(s),r>55295&&r<57344){if(!o){if(r>56319){(t-=3)>-1&&i.push(239,191,189);continue}if(s+1===n){(t-=3)>-1&&i.push(239,191,189);continue}o=r;continue}if(r<56320){(t-=3)>-1&&i.push(239,191,189),o=r;continue}r=65536+(o-55296<<10|r-56320)}else o&&(t-=3)>-1&&i.push(239,191,189);if(o=null,r<128){if((t-=1)<0)break;i.push(r)}else if(r<2048){if((t-=2)<0)break;i.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;i.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;i.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return i}function Qe(e,t,r){const n=[];for(;t<r;){const o=e[t];let i=null,s=o>239?4:o>223?3:o>191?2:1;if(t+s<=r){let r,n,a,c;switch(s){case 1:o<128&&(i=o);break;case 2:r=e[t+1],128==(192&r)&&(c=(31&o)<<6|63&r,c>127&&(i=c));break;case 3:r=e[t+1],n=e[t+2],128==(192&r)&&128==(192&n)&&(c=(15&o)<<12|(63&r)<<6|63&n,c>2047&&(c<55296||c>57343)&&(i=c));break;case 4:r=e[t+1],n=e[t+2],a=e[t+3],128==(192&r)&&128==(192&n)&&128==(192&a)&&(c=(15&o)<<18|(63&r)<<12|(63&n)<<6|63&a,c>65535&&c<1114112&&(i=c))}}null===i?(i=65533,s=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),t+=s}return function(e){const t=e.length;if(t<=Ye)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=Ye));return r}(n)}const Ye=4096;class Xe{constructor(e=256){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let t=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const r=t.length-(this.maxCursor-this.cursor)-1;t.set(e,r)}else{if(t){const e=t.length-(this.maxCursor-this.cursor)-1;e<t.length&&(this.chunks[this.chunks.length-1]=t.subarray(0,e),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(t=Ke(this.chunkSize),this.chunks.push(t),this.maxCursor+=t.length,null===this._initReuseChunk&&(this._initReuseChunk=t),t.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let t;if(1===this.chunks.length){const r=this.chunks[0];e&&this.cursor>r.length/2?(t=this.cursor===r.length?r:r.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):t=Je(r,0,this.cursor)}else t=We(this.chunks,this.cursor);return e&&this.reset(),t}}const et="CBOR decode error:",tt="CBOR encode error:",rt=[];function nt(e,t,r){if(e.length-t<r)throw new Error(`${et} not enough data for type`)}rt[23]=1,rt[24]=2,rt[25]=3,rt[26]=5,rt[27]=9;const ot=[24,256,65536,4294967296,BigInt("18446744073709551616")];function it(e,t,r){nt(e,t,1);const n=e[t];if(!0===r.strict&&n<ot[0])throw new Error(`${et} integer encoded in more bytes than necessary (strict decode)`);return n}function st(e,t,r){nt(e,t,2);const n=e[t]<<8|e[t+1];if(!0===r.strict&&n<ot[1])throw new Error(`${et} integer encoded in more bytes than necessary (strict decode)`);return n}function at(e,t,r){nt(e,t,4);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];if(!0===r.strict&&n<ot[2])throw new Error(`${et} integer encoded in more bytes than necessary (strict decode)`);return n}function ct(e,t,r){nt(e,t,8);const n=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3],o=16777216*e[t+4]+(e[t+5]<<16)+(e[t+6]<<8)+e[t+7],i=(BigInt(n)<<BigInt(32))+BigInt(o);if(!0===r.strict&&i<ot[3])throw new Error(`${et} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(!0===r.allowBigInt)return i;throw new Error(`${et} integers outside of the safe integer range are not supported`)}function ut(e,t){return ht(e,0,t.value)}function ht(e,t,r){if(r<ot[0]){const n=Number(r);e.push([t|n])}else if(r<ot[1]){const n=Number(r);e.push([24|t,n])}else if(r<ot[2]){const n=Number(r);e.push([25|t,n>>>8,255&n])}else if(r<ot[3]){const n=Number(r);e.push([26|t,n>>>24&255,n>>>16&255,n>>>8&255,255&n])}else{const n=BigInt(r);if(!(n<ot[4]))throw new Error(`${et} encountered BigInt larger than allowable range`);{const r=[27|t,0,0,0,0,0,0,0];let o=Number(n&BigInt(4294967295)),i=Number(n>>BigInt(32)&BigInt(4294967295));r[8]=255&o,o>>=8,r[7]=255&o,o>>=8,r[6]=255&o,o>>=8,r[5]=255&o,r[4]=255&i,i>>=8,r[3]=255&i,i>>=8,r[2]=255&i,i>>=8,r[1]=255&i,e.push(r)}}}ut.encodedSize=function(e){return ht.encodedSize(e.value)},ht.encodedSize=function(e){return e<ot[0]?1:e<ot[1]?2:e<ot[2]?3:e<ot[3]?5:9},ut.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const lt=BigInt(-1),ft=BigInt(1);function dt(e,t){const r=t.value,n="bigint"==typeof r?r*lt-ft:-1*r-1;ht(e,t.type.majorEncoded,n)}function yt(e,t,r,n){nt(e,t,r+n);const o=Je(e,t+r,t+r+n);return new Le(Ue.bytes,o,r+n)}function pt(e,t,r,n){return yt(e,t,1,r)}function wt(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===Ue.string?Ve(e.value):e.value),e.encodedBytes}function gt(e,t){const r=wt(t);ht(e,t.type.majorEncoded,r.length),e.push(r)}function bt(e,t,r,n,o){const i=r+n;nt(e,t,i);const s=new Le(Ue.string,Ge(e,t+r,t+i),i);return!0===o.retainStringBytes&&(s.byteValue=Je(e,t+r,t+i)),s}function mt(e,t,r,n){return bt(e,t,1,r,n)}dt.encodedSize=function(e){const t=e.value,r="bigint"==typeof t?t*lt-ft:-1*t-1;return r<ot[0]?1:r<ot[1]?2:r<ot[2]?3:r<ot[3]?5:9},dt.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0},gt.encodedSize=function(e){const t=wt(e);return ht.encodedSize(t.length)+t.length},gt.compareTokens=function(e,t){return r=wt(e),n=wt(t),r.length<n.length?-1:r.length>n.length?1:function(e,t){if(Fe(e)&&Fe(t))return e.compare(t);for(let r=0;r<e.length;r++)if(e[r]!==t[r])return e[r]<t[r]?-1:1;return 0}(r,n);var r,n};const vt=gt;function Et(e,t,r,n){return new Le(Ue.array,n,r)}function kt(e,t,r,n){return Et(0,0,1,r)}function xt(e,t){ht(e,Ue.array.majorEncoded,t.value)}function At(e,t,r,n){return new Le(Ue.map,n,r)}function It(e,t,r,n){return At(0,0,1,r)}function Ct(e,t){ht(e,Ue.map.majorEncoded,t.value)}function Tt(e,t,r,n){return new Le(Ue.tag,r,1)}function Nt(e,t){ht(e,Ue.tag.majorEncoded,t.value)}function jt(e,t,r){if(r){if(!1===r.allowNaN&&Number.isNaN(e))throw new Error(`${et} NaN values are not supported`);if(!1===r.allowInfinity&&(e===1/0||e===-1/0))throw new Error(`${et} Infinity values are not supported`)}return new Le(Ue.float,e,t)}function Dt(e,t,r){const n=t.value;if(!1===n)e.push([20|Ue.float.majorEncoded]);else if(!0===n)e.push([21|Ue.float.majorEncoded]);else if(null===n)e.push([22|Ue.float.majorEncoded]);else if(void 0===n)e.push([23|Ue.float.majorEncoded]);else{let t,i=!1;r&&!0===r.float64||(Pt(n),t=Ot($t,1),n===t||Number.isNaN(n)?($t[0]=249,e.push($t.slice(0,3)),i=!0):(_t(n),t=Ut($t,1),n===t&&($t[0]=250,e.push($t.slice(0,5)),i=!0))),i||(o=n,Bt.setFloat64(0,o,!1),t=Lt($t,1),$t[0]=251,e.push($t.slice(0,9)))}var o}xt.compareTokens=ut.compareTokens,xt.encodedSize=function(e){return ht.encodedSize(e.value)},Ct.compareTokens=ut.compareTokens,Ct.encodedSize=function(e){return ht.encodedSize(e.value)},Nt.compareTokens=ut.compareTokens,Nt.encodedSize=function(e){return ht.encodedSize(e.value)},Dt.encodedSize=function(e,t){const r=e.value;if(!1===r||!0===r||null==r)return 1;if(!t||!0!==t.float64){Pt(r);let e=Ot($t,1);if(r===e||Number.isNaN(r))return 3;if(_t(r),e=Ut($t,1),r===e)return 5}return 9};const St=new ArrayBuffer(9),Bt=new DataView(St,1),$t=new Uint8Array(St,0);function Pt(e){if(e===1/0)Bt.setUint16(0,31744,!1);else if(e===-1/0)Bt.setUint16(0,64512,!1);else if(Number.isNaN(e))Bt.setUint16(0,32256,!1);else{Bt.setFloat32(0,e);const t=Bt.getUint32(0),r=(2139095040&t)>>23,n=8388607&t;if(255===r)Bt.setUint16(0,31744,!1);else if(0===r)Bt.setUint16(0,(2147483648&e)>>16|n>>13,!1);else{const e=r-127;e<-24?Bt.setUint16(0,0):e<-14?Bt.setUint16(0,(2147483648&t)>>16|1<<24+e,!1):Bt.setUint16(0,(2147483648&t)>>16|e+15<<10|n>>13,!1)}}}function Ot(e,t){if(e.length-t<2)throw new Error(`${et} not enough data for float16`);const r=(e[t]<<8)+e[t+1];if(31744===r)return 1/0;if(64512===r)return-1/0;if(32256===r)return NaN;const n=r>>10&31,o=1023&r;let i;return i=0===n?o*2**-24:31!==n?(o+1024)*2**(n-25):0===o?1/0:NaN,32768&r?-i:i}function _t(e){Bt.setFloat32(0,e,!1)}function Ut(e,t){if(e.length-t<4)throw new Error(`${et} not enough data for float32`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,4).getFloat32(0,!1)}function Lt(e,t){if(e.length-t<8)throw new Error(`${et} not enough data for float64`);const r=(e.byteOffset||0)+t;return new DataView(e.buffer,r,8).getFloat64(0,!1)}function Mt(e,t,r){throw new Error(`${et} encountered invalid minor (${r}) for major ${e[t]>>>5}`)}function zt(e){return()=>{throw new Error(`${et} ${e}`)}}Dt.compareTokens=ut.compareTokens;const Ht=[];for(let e=0;e<=23;e++)Ht[e]=Mt;Ht[24]=function(e,t,r,n){return new Le(Ue.uint,it(e,t+1,n),2)},Ht[25]=function(e,t,r,n){return new Le(Ue.uint,st(e,t+1,n),3)},Ht[26]=function(e,t,r,n){return new Le(Ue.uint,at(e,t+1,n),5)},Ht[27]=function(e,t,r,n){return new Le(Ue.uint,ct(e,t+1,n),9)},Ht[28]=Mt,Ht[29]=Mt,Ht[30]=Mt,Ht[31]=Mt;for(let e=32;e<=55;e++)Ht[e]=Mt;Ht[56]=function(e,t,r,n){return new Le(Ue.negint,-1-it(e,t+1,n),2)},Ht[57]=function(e,t,r,n){return new Le(Ue.negint,-1-st(e,t+1,n),3)},Ht[58]=function(e,t,r,n){return new Le(Ue.negint,-1-at(e,t+1,n),5)},Ht[59]=function(e,t,r,n){const o=ct(e,t+1,n);if("bigint"!=typeof o){const e=-1-o;if(e>=Number.MIN_SAFE_INTEGER)return new Le(Ue.negint,e,9)}if(!0!==n.allowBigInt)throw new Error(`${et} integers outside of the safe integer range are not supported`);return new Le(Ue.negint,lt-BigInt(o),9)},Ht[60]=Mt,Ht[61]=Mt,Ht[62]=Mt,Ht[63]=Mt;for(let e=64;e<=87;e++)Ht[e]=pt;Ht[88]=function(e,t,r,n){return yt(e,t,2,it(e,t+1,n))},Ht[89]=function(e,t,r,n){return yt(e,t,3,st(e,t+1,n))},Ht[90]=function(e,t,r,n){return yt(e,t,5,at(e,t+1,n))},Ht[91]=function(e,t,r,n){const o=ct(e,t+1,n);if("bigint"==typeof o)throw new Error(`${et} 64-bit integer bytes lengths not supported`);return yt(e,t,9,o)},Ht[92]=Mt,Ht[93]=Mt,Ht[94]=Mt,Ht[95]=zt("indefinite length bytes/strings are not supported");for(let e=96;e<=119;e++)Ht[e]=mt;Ht[120]=function(e,t,r,n){return bt(e,t,2,it(e,t+1,n),n)},Ht[121]=function(e,t,r,n){return bt(e,t,3,st(e,t+1,n),n)},Ht[122]=function(e,t,r,n){return bt(e,t,5,at(e,t+1,n),n)},Ht[123]=function(e,t,r,n){const o=ct(e,t+1,n);if("bigint"==typeof o)throw new Error(`${et} 64-bit integer string lengths not supported`);return bt(e,t,9,o,n)},Ht[124]=Mt,Ht[125]=Mt,Ht[126]=Mt,Ht[127]=zt("indefinite length bytes/strings are not supported");for(let e=128;e<=151;e++)Ht[e]=kt;Ht[152]=function(e,t,r,n){return Et(0,0,2,it(e,t+1,n))},Ht[153]=function(e,t,r,n){return Et(0,0,3,st(e,t+1,n))},Ht[154]=function(e,t,r,n){return Et(0,0,5,at(e,t+1,n))},Ht[155]=function(e,t,r,n){const o=ct(e,t+1,n);if("bigint"==typeof o)throw new Error(`${et} 64-bit integer array lengths not supported`);return Et(0,0,9,o)},Ht[156]=Mt,Ht[157]=Mt,Ht[158]=Mt,Ht[159]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${et} indefinite length items not allowed`);return Et(0,0,1,1/0)};for(let e=160;e<=183;e++)Ht[e]=It;Ht[184]=function(e,t,r,n){return At(0,0,2,it(e,t+1,n))},Ht[185]=function(e,t,r,n){return At(0,0,3,st(e,t+1,n))},Ht[186]=function(e,t,r,n){return At(0,0,5,at(e,t+1,n))},Ht[187]=function(e,t,r,n){const o=ct(e,t+1,n);if("bigint"==typeof o)throw new Error(`${et} 64-bit integer map lengths not supported`);return At(0,0,9,o)},Ht[188]=Mt,Ht[189]=Mt,Ht[190]=Mt,Ht[191]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${et} indefinite length items not allowed`);return At(0,0,1,1/0)};for(let e=192;e<=215;e++)Ht[e]=Tt;Ht[216]=function(e,t,r,n){return new Le(Ue.tag,it(e,t+1,n),2)},Ht[217]=function(e,t,r,n){return new Le(Ue.tag,st(e,t+1,n),3)},Ht[218]=function(e,t,r,n){return new Le(Ue.tag,at(e,t+1,n),5)},Ht[219]=function(e,t,r,n){return new Le(Ue.tag,ct(e,t+1,n),9)},Ht[220]=Mt,Ht[221]=Mt,Ht[222]=Mt,Ht[223]=Mt;for(let e=224;e<=243;e++)Ht[e]=zt("simple values are not supported");Ht[244]=Mt,Ht[245]=Mt,Ht[246]=Mt,Ht[247]=function(e,t,r,n){if(!1===n.allowUndefined)throw new Error(`${et} undefined values are not supported`);return!0===n.coerceUndefinedToNull?new Le(Ue.null,null,1):new Le(Ue.undefined,void 0,1)},Ht[248]=zt("simple values are not supported"),Ht[249]=function(e,t,r,n){return jt(Ot(e,t+1),3,n)},Ht[250]=function(e,t,r,n){return jt(Ut(e,t+1),5,n)},Ht[251]=function(e,t,r,n){return jt(Lt(e,t+1),9,n)},Ht[252]=Mt,Ht[253]=Mt,Ht[254]=Mt,Ht[255]=function(e,t,r,n){if(!1===n.allowIndefinite)throw new Error(`${et} indefinite length items not allowed`);return new Le(Ue.break,void 0,1)};const Ft=[];for(let e=0;e<24;e++)Ft[e]=new Le(Ue.uint,e,1);for(let e=-1;e>=-24;e--)Ft[31-e]=new Le(Ue.negint,e,1);Ft[64]=new Le(Ue.bytes,new Uint8Array(0),1),Ft[96]=new Le(Ue.string,"",1),Ft[128]=new Le(Ue.array,0,1),Ft[160]=new Le(Ue.map,0,1),Ft[244]=new Le(Ue.false,!1,1),Ft[245]=new Le(Ue.true,!0,1),Ft[246]=new Le(Ue.null,null,1);const Rt={float64:!1,mapSorter:function(e,t){const r=Array.isArray(e[0])?e[0][0]:e[0],n=Array.isArray(t[0])?t[0][0]:t[0];if(r.type!==n.type)return r.type.compare(n.type);const o=r.type.major,i=Gt[o].compareTokens(r,n);return 0===i&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),i},quickEncodeToken:function(e){switch(e.type){case Ue.false:return qe([244]);case Ue.true:return qe([245]);case Ue.null:return qe([246]);case Ue.bytes:return e.value.length?void 0:qe([64]);case Ue.string:return""===e.value?qe([96]):void 0;case Ue.array:return 0===e.value?qe([128]):void 0;case Ue.map:return 0===e.value?qe([160]):void 0;case Ue.uint:return e.value<24?qe([Number(e.value)]):void 0;case Ue.negint:if(e.value>=-24)return qe([31-Number(e.value)])}}},Gt=function(){const e=[];return e[Ue.uint.major]=ut,e[Ue.negint.major]=dt,e[Ue.bytes.major]=gt,e[Ue.string.major]=vt,e[Ue.array.major]=xt,e[Ue.map.major]=Ct,e[Ue.tag.major]=Nt,e[Ue.float.major]=Dt,e}(),Vt=new Xe;class qt{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error(`${tt} object contains circular references`);return new qt(t,e)}}const Jt={null:new Le(Ue.null,null),undefined:new Le(Ue.undefined,void 0),true:new Le(Ue.true,!0),false:new Le(Ue.false,!1),emptyArray:new Le(Ue.array,0),emptyMap:new Le(Ue.map,0)},Wt={number:(e,t,r,n)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new Le(e>=0?Ue.uint:Ue.negint,e):new Le(Ue.float,e),bigint:(e,t,r,n)=>e>=BigInt(0)?new Le(Ue.uint,e):new Le(Ue.negint,e),Uint8Array:(e,t,r,n)=>new Le(Ue.bytes,e),string:(e,t,r,n)=>new Le(Ue.string,e),boolean:(e,t,r,n)=>e?Jt.true:Jt.false,null:(e,t,r,n)=>Jt.null,undefined:(e,t,r,n)=>Jt.undefined,ArrayBuffer:(e,t,r,n)=>new Le(Ue.bytes,new Uint8Array(e)),DataView:(e,t,r,n)=>new Le(Ue.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,r,n){if(!e.length)return!0===r.addBreakTokens?[Jt.emptyArray,new Le(Ue.break)]:Jt.emptyArray;n=qt.createCheck(n,e);const o=[];let i=0;for(const t of e)o[i++]=Kt(t,r,n);return r.addBreakTokens?[new Le(Ue.array,e.length),o,new Le(Ue.break)]:[new Le(Ue.array,e.length),o]},Object(e,t,r,n){const o="Object"!==t,i=o?e.keys():Object.keys(e),s=o?e.size:i.length;if(!s)return!0===r.addBreakTokens?[Jt.emptyMap,new Le(Ue.break)]:Jt.emptyMap;n=qt.createCheck(n,e);const a=[];let c=0;for(const t of i)a[c++]=[Kt(t,r,n),Kt(o?e.get(t):e[t],r,n)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(a,r),r.addBreakTokens?[new Le(Ue.map,s),a,new Le(Ue.break)]:[new Le(Ue.map,s),a]}};Wt.Map=Wt.Object,Wt.Buffer=Wt.Uint8Array;for(const e of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))Wt[`${e}Array`]=Wt.DataView;function Kt(e,t={},r){const n=function(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const t=typeof e;if(Oe.includes(t))return t;if("function"===t)return"Function";if(Array.isArray(e))return"Array";if(function(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}(e))return"Buffer";return function(e){const t=Object.prototype.toString.call(e).slice(8,-1);if(_e.includes(t))return t}(e)||"Object"}(e),o=t&&t.typeEncoders&&t.typeEncoders[n]||Wt[n];if("function"==typeof o){const i=o(e,n,t,r);if(null!=i)return i}const i=Wt[n];if(!i)throw new Error(`${tt} unsupported type: ${n}`);return i(e,n,t,r)}function Zt(e,t,r,n){if(Array.isArray(t))for(const o of t)Zt(e,o,r,n);else r[t.type.major](e,t,n)}function Qt(e,t,r){const n=Kt(e,r);if(!Array.isArray(n)&&r.quickEncodeToken){const e=r.quickEncodeToken(n);if(e)return e;const o=t[n.type.major];if(o.encodedSize){const e=o.encodedSize(n,r),t=new Xe(e);if(o(t,n,r),1!==t.chunks.length)throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);return Re(t.chunks[0])}}return Vt.reset(),Zt(Vt,n,t,r),Vt.toBytes(!0)}const Yt={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class Xt{constructor(e,t={}){this.pos=0,this.data=e,this.options=t}done(){return this.pos>=this.data.length}next(){const e=this.data[this.pos];let t=Ft[e];if(void 0===t){const r=Ht[e];if(!r)throw new Error(`${et} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const n=31&e;t=r(this.data,this.pos,n,this.options)}return this.pos+=t.encodedLength,t}}const er=Symbol.for("DONE"),tr=Symbol.for("BREAK");function rr(e,t){if(e.done())return er;const r=e.next();if(r.type===Ue.break)return tr;if(r.type.terminal)return r.value;if(r.type===Ue.array)return function(e,t,r){const n=[];for(let o=0;o<e.value;o++){const i=rr(t,r);if(i===tr){if(e.value===1/0)break;throw new Error(`${et} got unexpected break to lengthed array`)}if(i===er)throw new Error(`${et} found array but not enough entries (got ${o}, expected ${e.value})`);n[o]=i}return n}(r,e,t);if(r.type===Ue.map)return function(e,t,r){const n=!0===r.useMaps,o=n?void 0:{},i=n?new Map:void 0;for(let s=0;s<e.value;s++){const a=rr(t,r);if(a===tr){if(e.value===1/0)break;throw new Error(`${et} got unexpected break to lengthed map`)}if(a===er)throw new Error(`${et} found map but not enough entries (got ${s} [no key], expected ${e.value})`);if(!0!==n&&"string"!=typeof a)throw new Error(`${et} non-string keys not supported (got ${typeof a})`);if(!0===r.rejectDuplicateMapKeys&&(n&&i.has(a)||!n&&a in o))throw new Error(`${et} found repeat map key "${a}"`);const c=rr(t,r);if(c===er)throw new Error(`${et} found map but not enough entries (got ${s} [no value], expected ${e.value})`);n?i.set(a,c):o[a]=c}return n?i:o}(r,e,t);if(r.type===Ue.tag){if(t.tags&&"function"==typeof t.tags[r.value]){const n=rr(e,t);return t.tags[r.value](n)}throw new Error(`${et} tag not supported (${r.value})`)}throw new Error("unsupported")}const nr={float64:!0,typeEncoders:{Object:function(e){if(e.asCID!==e)return null;const t=V.asCID(e);if(!t)return null;const r=new Uint8Array(t.bytes.byteLength+1);return r.set(t.bytes,1),[new Le(Ue.tag,42),new Le(Ue.bytes,r)]},undefined:function(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")},number:function(e){if(Number.isNaN(e))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(e===1/0||e===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}}},or={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};or.tags[42]=function(e){if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return V.decode(e.subarray(1))};const ir="dag-cbor",sr=113,ar=e=>{return t=e,r=nr,r=Object.assign({},Rt,r),Qt(t,Gt,r);var t,r},cr=e=>function(e,t){if(!(e instanceof Uint8Array))throw new Error(`${et} data to decode must be a Uint8Array`);const r=(t=Object.assign({},Yt,t)).tokenizer||new Xt(e,t),n=rr(r,t);if(n===er)throw new Error(`${et} did not find any content to decode`);if(n===tr)throw new Error(`${et} got unexpected break`);if(!r.done())throw new Error(`${et} too many terminals, data makes no sense`);return n}(e,or),ur=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),hr=ne({name:"sha2-256",code:18,encode:ur("SHA-256")}),lr=(ne({name:"sha2-512",code:19,encode:ur("SHA-512")}),R),fr=()=>new Error("unsupported codec"),dr=e=>e?Array.isArray(e)?e.map(dr):V.parse(e):e,yr=(e,t={})=>{if(!e||"string"==typeof e)return e;if(Array.isArray(e))return e.map(yr);if(e["/"])return e["/"];const r=t.base||lr;return e.toString(r)},pr={[Be]:e,[sr]:t},wr={raw:t,"dag-pb":e,"dag-cbor":t};async function gr(e,t,r={}){t=dr(yr(t));const n=pr[t.code];if(!n)throw fr();const o=await e.block.get(t,{timeout:r.timeout}),i=await(async({bytes:e,codec:t,hasher:r})=>{if(!e)throw new Error('Missing required argument "bytes"');if(!t||!r)throw new Error("Missing required argument: codec or hasher");const n=t.decode(e),o=await r.digest(e),i=V.create(1,t.code,o);return new ce({value:n,bytes:e,cid:i})})({bytes:o,codec:n,hasher:hr});if(i.cid.code===Be)return JSON.parse((new TextDecoder).decode(i.value.Data));if(i.cid.code===sr){const e=i.value;return(r.links||[]).forEach((t=>{e[t]&&(e[t]=yr(e[t],r))})),e}}async function br(e,t,r,n={}){"dag-pb"===n.format&&(t=n.format);const o=wr[t];if(!o)throw fr();o.code===Be&&(r="string"==typeof r?r:JSON.stringify(r),r={Data:(new TextEncoder).encode(r),Links:[]}),o.code===sr&&(n.links||[]).forEach((e=>{r[e]&&(r[e]=dr(r[e]))}));const i=await(async({value:e,codec:t,hasher:r})=>{if(void 0===e)throw new Error('Missing required argument "value"');if(!t||!r)throw new Error("Missing required argument: codec or hasher");const n=t.encode(e),o=await r.digest(n),i=V.create(1,t.code,o);return new ce({value:e,bytes:n,cid:i})})({value:r,codec:o,hasher:hr});return await e.block.put(i.bytes,{cid:i.cid.bytes,version:i.cid.version,format:t,mhtype:"sha2-256",pin:n.pin,timeout:n.timeout}),(o.code===Be?i.cid.toV0():i.cid).toString(n.base||lr)}const mr=e=>null!=e;var vr=r(299);const Er=()=>new Error("Ipfs instance not defined"),kr=["next","refs"],xr=e=>0===e?"dag-pb":"dag-cbor",Ar=e=>Ir.isEntry(e)?xr(e.v):xr(e);class Ir{static async create(e,t,r,n,o=[],i,s=[],a){if(!mr(e))throw Er();if(!mr(t))throw new Error("Identity is required, cannot create entry");if(!mr(r))throw new Error("Entry requires an id");if(!mr(n))throw new Error("Entry requires data");if(!mr(o)||!Array.isArray(o))throw new Error("'next' argument is not an array");const c={hash:null,id:r,payload:n,next:o.filter(mr).map((e=>e.hash?e.hash:e)),refs:s,v:2,clock:i||new w(t.publicKey)},u=await t.provider.sign(t,Ir.toBuffer(c));return c.key=t.publicKey,c.identity=t.toJSON(),c.sig=u,c.hash=await Ir.toMultihash(e,c,a),c}static async verify(e,t){if(!e)throw new Error("Identity-provider is required, cannot verify entry");if(!Ir.isEntry(t))throw new Error("Invalid Log entry");if(!t.key)throw new Error("Entry doesn't have a key");if(!t.sig)throw new Error("Entry doesn't have a signature");const r=Ir.toEntry(t,{presigned:!0}),n=t.v<1?"v0":"v1";return e.verify(t.sig,t.key,Ir.toBuffer(r),n)}static toBuffer(e){const t=0===e.v?JSON.stringify(e):vr(e);return Buffer.from(t)}static async toMultihash(e,t,r=!1){if(!e)throw Er();if(!Ir.isEntry(t))throw new Error("Invalid object format, cannot generate entry hash");const n=Ir.toEntry(t);return br(e,Ar(n.v),n,{links:kr,pin:r})}static toEntry(e,{presigned:t=!1,includeHash:r=!1}={}){const n={hash:r?e.hash:null,id:e.id,payload:e.payload,next:e.next},o=e.v;return o>1&&(n.refs=e.refs),n.v=e.v,n.clock=new w(e.clock.id,e.clock.time),t||(n.key=e.key,o>0&&(n.identity=e.identity),n.sig=e.sig),n}static async fromMultihash(e,t){if(!e)throw Er();if(!t)throw new Error(`Invalid hash: ${t}`);const r=await gr(e,t,{links:kr}),n=Ir.toEntry(r);return n.hash=t,n}static isEntry(e){return e&&void 0!==e.id&&void 0!==e.next&&void 0!==e.payload&&void 0!==e.v&&void 0!==e.hash&&void 0!==e.clock&&(void 0!==e.refs||e.v<2)}static compare(e,t){const r=w.compare(e.clock,t.clock);return 0===r?e.clock.id<t.clock.id?-1:1:r}static isEqual(e,t){return e.hash===t.hash}static isParent(e,t){return t.next.indexOf(e.hash)>-1}static findChildren(e,t){let r=[],n=t.find((t=>Ir.isParent(e,t))),o=e;for(;n;)r.push(n),o=n,n=t.find((e=>Ir.isParent(o,e)));return r=r.sort(((e,t)=>e.clock.time>t.clock.time)),r}}const Cr=Ir;async function Tr(e,t){if(t(await e()))return Tr(e,t)}const{isEntry:Nr,fromMultihash:jr}=Cr,Dr=e=>e&&e.length>0;class Sr{static async fetchParallel(e,t,{length:r,exclude:n=[],shouldExclude:o,timeout:i,concurrency:s,onProgressCallback:a}){return(await f(t,(async t=>Sr.fetchAll(e,t,{length:r,exclude:n,shouldExclude:o,timeout:i,onProgressCallback:a,concurrency:s})),{concurrency:Math.max(s||t.length,1)})).reduce(((e,t)=>e.concat(t)),[])}static async fetchAll(e,t,{length:r=-1,exclude:n=[],shouldExclude:o,timeout:i,onProgressCallback:s,onStartProgressCallback:a,concurrency:c=32,delay:u=0}={}){const h=[],l={},d={},y=Array.isArray(t)?{0:t.slice()}:{0:[t]};let p=0,w=0,g=0;o=o||(()=>!1);const b=(e,t)=>{d[e]||o(e)||(y[t]||(y[t]=[]),y[t].includes(e)||y[t].push(e),d[e]=!0)},m=async t=>{if(t&&!l[t]&&!o(t))return new Promise((async(n,c)=>{const f=i&&i>0?setTimeout((()=>{console.warn(`Warning: Couldn't fetch entry '${t}', request timed out (${i}ms)`),n()}),i):null;a&&a(t,null,0,h.length);try{const i=await jr(e,t);if(u>0){const e=(e=0)=>new Promise((t=>setTimeout(t,e)));await e(u)}(e=>{if(Nr(e)&&!l[e.hash]&&!o(e.hash)){const t=e.clock.time;w=Math.max(w,t),g=h.length>0?Math.min(h[h.length-1].clock.time,g):w;const n=h.length>=r&&t>=g,i=e=>w-t+(e+1)*e;!(r<0||h.length<r||n)||o(e.hash)||l[e.hash]||(h.push(e),l[e.hash]=!0,s&&s(e)),r<0?(e.next.forEach(b),e.refs&&e.refs.forEach(b)):((h.length<r||t>g||t===g&&!l[e.hash]&&!o(e.hash))&&e.next.forEach((e=>b(e,i(0)))),e.refs&&h.length+e.refs.length<=r&&e.refs.forEach(((e,t)=>b(e,i(t)))))}})(i),n()}catch(e){c(e)}finally{clearTimeout(f)}}))};return n.forEach((e=>{l[e.hash||e]=!0})),await Tr((async()=>{if(p<c){const e=((e=1)=>Object.keys(y).reduce(((t,r,n)=>{const o=y[r];for(;o.length>0&&t.length<e;){const e=o.shift();t.push(e)}return 0===o.length&&delete y[r],t}),[]))(c);p+=e.length,await f(e,m,{concurrency:c}),p-=e.length}}),(()=>void 0!==Object.values(y).find(Dr))),h}}const Br=Sr;function $r(e,t,r){const n=w.compare(e.clock,t.clock);return 0===n?r(e,t):n}function Pr(e,t,r){return e.clock.id===t.clock.id?r(e,t):e.clock.id<t.clock.id?-1:1}const Or={SortByClocks:$r,SortByClockId:Pr,LastWriteWins:function(e,t){const r=(e,t)=>e,n=(e,t)=>Pr(e,t,r);return((e,t)=>$r(e,t,n))(e,t)},SortByEntryHash:function(e,t){const r=(e,t)=>e.hash<t.hash?-1:1,n=(e,t)=>Pr(e,t,r);return((e,t)=>$r(e,t,n))(e,t)},NoZeroes:function(e){const t=`Your log's tiebreaker function, ${e.name}, has returned zero and therefore cannot be`;return(r,n)=>{const o=e(r,n);if(0===o)throw Error(t);return o}}},_r=()=>new Error("IPFS instance not defined"),Ur=()=>new Error("Log instance not defined"),Lr=()=>new Error("Given argument is not an instance of Log"),Mr=()=>new Error("lt or lte must be a string or array of Entries"),zr=function(e,t){const r={};return e.forEach((e=>r[t?e[t]:e]=e)),Object.keys(r).map((e=>r[e]))},{LastWriteWins:Hr,NoZeroes:Fr}=Or,{fetchAll:Rr,fetchParallel:Gr}=Br,{compare:Vr,isEntry:qr}=Cr,Jr=["heads"],Wr=(e,t)=>e.slice(e.length-Math.min(e.length,t),e.length),Kr=class{static async toMultihash(e,t,{format:r}={}){if(!mr(e))throw _r();if(!mr(t))throw Ur();if(mr(r)||(r="dag-cbor"),t.values.length<1)throw new Error("Can't serialize an empty log");return br(e,r,t.toJSON(),{links:Jr})}static async fromMultihash(e,t,{length:r=-1,exclude:n=[],shouldExclude:o,timeout:i,concurrency:s,sortFn:a,onProgressCallback:c}){if(!mr(e))throw _r();if(!mr(t))throw new Error(`Invalid hash: ${t}`);const u=await gr(e,t,{links:Jr});if(!u.heads||!u.id)throw Lr();a=a||Fr(Hr);const h=await Rr(e,u.heads,{length:r,exclude:n,shouldExclude:o,timeout:i,concurrency:s,onProgressCallback:c}),l=u.id,f=r>-1?Wr(h.sort(a),r):h,d=f.filter((e=>u.heads.includes(e.hash)));return{logId:l,entries:f,heads:d}}static async fromEntryHash(e,t,{length:r=-1,exclude:n=[],shouldExclude:o,timeout:i,concurrency:s,sortFn:a,onProgressCallback:c}){if(!mr(e))throw _r();if(!mr(t))throw new Error("'hash' must be defined");const u=Array.isArray(t)?t:[t];r=r>-1?Math.max(r,1):r;const h=await Gr(e,u,{length:r,exclude:n,shouldExclude:o,timeout:i,concurrency:s,onProgressCallback:c});return a=a||Fr(Hr),{entries:r>-1?Wr(h.sort(a),r):h}}static async fromJSON(e,t,{length:r=-1,timeout:n,concurrency:o,onProgressCallback:i}){if(!mr(e))throw _r();const{id:s,heads:a}=t,c=a.map((e=>e.hash));return{logId:s,entries:(await Gr(e,c,{length:r,timeout:n,concurrency:o,onProgressCallback:i})).sort(Vr),heads:a}}static async fromEntry(e,t,{length:r=-1,exclude:n=[],shouldExclude:o,timeout:i,concurrency:s,onProgressCallback:a}){if(!mr(e))throw _r();if(!mr(t))throw new Error("'sourceEntries' must be defined");if(!Array.isArray(t)&&!qr(t))throw new Error("'sourceEntries' argument must be an array of Entry instances or a single Entry");Array.isArray(t)||(t=[t]),r=r>-1?Math.max(r,t.length):r;const c=t.map((e=>e.hash)),u=await Gr(e,c,{length:r,exclude:n,shouldExclude:o,timeout:i,concurrency:s,onProgressCallback:a}),h=t.concat(u).concat(n),l=zr(h,"hash").sort(Vr),f=l.slice(r>-1?-r:-l.length),d=((e,t)=>{const r=e.slice(t.length,e.length);return t.concat(r)})(f,function(e,t,r){const n={},o={};return e.forEach((e=>o[r?e[r]:e]=!0)),t.reduce(((e,t)=>{const i=void 0!==o[r?t[r]:t],s=void 0!==n[r?t[r]:t];return i||s||(e.push(t),n[r?t[r]:t]=!0),e}),[])}(f,t,"hash"));return{logId:d[d.length-1].id,entries:d}}},Zr=class{async canAppend(e,t){return!0}},Qr=class{constructor(e={}){this._cache=e}set(e,t){this._cache[e]=t}get(e){return this._cache[e]}delete(e){return delete this._cache[e]}add(e){this._cache=Object.assign(this._cache,e)}get length(){return Object.values(this._cache).length}},{LastWriteWins:Yr,NoZeroes:Xr}=Or,en=e=>e.hash,tn=(e,t)=>e.concat(t),rn=e=>e.next,nn=(e,t)=>Math.max(e,t.clock.time),on=(e,t)=>(e[t.hash]=t,e);class sn extends y{constructor(e,t,{logId:r,access:n,entries:o,heads:i,clock:s,sortFn:a,concurrency:c}={}){if(!mr(e))throw _r();if(!mr(t))throw new Error("Identity is required");if(mr(n)||(n=new Zr),mr(o)&&!Array.isArray(o))throw new Error("'entries' argument must be an array of Entry instances");if(mr(i)&&!Array.isArray(i))throw new Error("'heads' argument must be an array");mr(a)||(a=Yr),super(),this._sortFn=Xr(a),this._storage=e,this._id=r||(new Date).getTime().toString(),this._access=n,this._identity=t;const u=(o||[]).reduce(on,{});this._entryIndex=new Qr(u),o=Object.values(u)||[],i=i||sn.findHeads(o),this._headsIndex=i.reduce(on,{}),this._nextsIndex={},o.forEach((e=>e.next.forEach((t=>this._nextsIndex[t]=e.hash)))),this._length=o.length;const h=Math.max(s?s.time:0,this.heads.reduce(nn,0));this._clock=new w(this._identity.publicKey,h),this.joinConcurrency=c||16}get id(){return this._id}get clock(){return this._clock}get length(){return this._length}get values(){return Object.values(this.traverse(this.heads)).reverse()}get heads(){return Object.values(this._headsIndex).sort(this._sortFn).reverse()}get tails(){return sn.findTails(this.values)}get tailHashes(){return sn.findTailHashes(this.values)}setIdentity(e){this._identity=e;const t=Math.max(this.clock.time,this.heads.reduce(nn,0));this._clock=new w(this._identity.publicKey,t)}get(e){return this._entryIndex.get(e)}has(e){return void 0!==this._entryIndex.get(e.hash||e)}traverse(e,t=-1,r){let n=e.sort(this._sortFn).reverse(),o={};const i={};let s=0;const a=e=>this.get(e),c=e=>{e&&!o[e.hash]&&(n=[e,...n].sort(this._sortFn).reverse(),o[e.hash]=!0)};for(;n.length>0&&(s<t||t<0);){const e=n.shift();if(i[(u=e).hash]=u,o[u.hash]=!0,s++,r&&r===e.hash)break;e.next.map(a).filter(mr).forEach(c)}var u;return n=[],o={},i}async append(e,t=1,r=!1){const n=Math.max(this.clock.time,this.heads.reduce(nn,0))+1;this._clock=new w(this.clock.id,n);const o=Object.values(this.traverse(this.heads,Math.max(t,this.heads.length))),i=(e=>{const t=new Set;for(let r=1;r<=e;r*=2){const e=Math.min(r-1,o.length-1);t.add(o[e])}return t})(Math.min(t,o.length));o.length<t&&o[o.length-1]&&i.add(o[o.length-1]);const s=Object.keys(this.heads.reverse().reduce(on,{})),a=Array.from(i).map(en).filter((e=>!s.includes(e))),c=await Cr.create(this._storage,this._identity,this.id,e,s,this.clock,a,r);if(!await this._access.canAppend(c,this._identity.provider))throw new Error(`Could not append entry, key "${this._identity.id}" is not allowed to write to the log`);return this._entryIndex.set(c.hash,c),s.forEach((e=>this._nextsIndex[e]=c.hash)),this._headsIndex={},this._headsIndex[c.hash]=c,this._length++,c}iterator({gt:e,gte:t,lt:r,lte:n,amount:o=-1}={}){if(0===o)return function*(){}();if("string"==typeof n&&(n=[this.get(n)]),"string"==typeof r&&(r=[this.get(this.get(r).next[0])]),n&&!Array.isArray(n))throw Mr();if(r&&!Array.isArray(r))throw Mr();const i=(n||r||this.heads).filter(mr),s=t?this.get(t).hash:e?this.get(e).hash:null,a=s?-1:o||-1,c=this.traverse(i,a,s);let u=Object.values(c);return e&&u.pop(),(e||t)&&o>-1&&(u=u.slice(u.length-o,u.length)),function*(){for(const e in u)yield u[e]}()}async join(e,t=-1){if(!mr(e))throw Ur();if(!sn.isLog(e))throw Lr();if(this.id!==e.id)return;const r=sn.difference(e,this),n=this._identity.provider,o=async e=>{if(!await this._access.canAppend(e,n))throw new Error(`Could not append entry, key "${e.identity.id}" is not allowed to write to the log`)},i=Object.values(r);await f(i,(async e=>{await o(e),await(async e=>{const t=await Cr.verify(n,e),r=e.identity?e.identity.publicKey:e.key;if(!t)throw new Error(`Could not validate signature "${e.sig}" for entry "${e.hash}" and key "${r}"`)})(e)}),{concurrency:this.joinConcurrency}),Object.values(r).forEach((e=>{this.get(e.hash)||this._length++,e.next.forEach((t=>this._nextsIndex[t]=e.hash))})),this._entryIndex.add(r);const s=Object.values(r).map(rn).reduce(tn,[]),a=sn.findHeads(Object.values(Object.assign({},this._headsIndex,e._headsIndex))).filter((e=>!s.find((t=>t===e.hash)))).filter((e=>!this._nextsIndex[e.hash])).reduce(on,{});if(this._headsIndex=a,t>-1){let e=this.values;e=e.slice(-t),this._entryIndex=null,this._entryIndex=new Qr(e.reduce(on,{})),this._headsIndex=sn.findHeads(e).reduce(on,{}),this._length=this._entryIndex.length}const c=Object.values(this._headsIndex).reduce(nn,0);return this._clock=new w(this.clock.id,Math.max(this.clock.time,c)),this}toJSON(){return{id:this.id,heads:this.heads.sort(this._sortFn).reverse().map(en)}}toSnapshot(){return{id:this.id,heads:this.heads,values:this.values}}toBuffer(){return Buffer.from(JSON.stringify(this.toJSON()))}toString(e){return this.values.slice().reverse().map(((t,r)=>{const n=Cr.findChildren(t,this.values).length;let o=new Array(Math.max(n-1,0));return o=n>1?o.fill("  "):o,o=n>0?o.concat([""]):o,o.join("")+(e?e(t.payload):t.payload)})).join("\n")}static isLog(e){return void 0!==e.id&&void 0!==e.heads&&void 0!==e._entryIndex}toMultihash({format:e}={}){return Kr.toMultihash(this._storage,this,{format:e})}static async fromMultihash(e,t,r,{access:n,length:o=-1,exclude:i=[],shouldExclude:s,timeout:a,concurrency:c,sortFn:u,onProgressCallback:h}={}){const{logId:l,entries:f,heads:d}=await Kr.fromMultihash(e,r,{length:o,exclude:i,shouldExclude:s,timeout:a,onProgressCallback:h,concurrency:c,sortFn:u});return new sn(e,t,{logId:l,access:n,entries:f,heads:d,sortFn:u})}static async fromEntryHash(e,t,r,{logId:n,access:o,length:i=-1,exclude:s=[],shouldExclude:a,timeout:c,concurrency:u,sortFn:h,onProgressCallback:l}={}){const{entries:f}=await Kr.fromEntryHash(e,r,{length:i,exclude:s,shouldExclude:a,timeout:c,concurrency:u,onProgressCallback:l});return new sn(e,t,{logId:n,access:o,entries:f,sortFn:h})}static async fromJSON(e,t,r,{access:n,length:o=-1,timeout:i,sortFn:s,onProgressCallback:a}={}){const{logId:c,entries:u}=await Kr.fromJSON(e,r,{length:o,timeout:i,onProgressCallback:a});return new sn(e,t,{logId:c,access:n,entries:u,sortFn:s})}static async fromEntry(e,t,r,{access:n,length:o=-1,exclude:i=[],timeout:s,concurrency:a,sortFn:c,onProgressCallback:u}={}){const{logId:h,entries:l}=await Kr.fromEntry(e,r,{length:o,exclude:i,timeout:s,concurrency:a,onProgressCallback:u});return new sn(e,t,{logId:h,access:n,entries:l,sortFn:c})}static findHeads(e){const t=e.reduce(((e,t,r,n)=>(t.next.forEach((r=>e[r]=t.hash)),e)),{});return e.filter((e=>void 0===t[e.hash])).sort(((e,t)=>e.clock.id>t.clock.id))}static findTails(e){const t={},r=[],n={};let o=[];e.forEach((e=>{0===e.next.length&&r.push(e),e.next.forEach((r=>{t[r]||(t[r]=[]),t[r].push(e)})),o=o.concat(e.next),n[e.hash]=!0}));const i=o.filter((e=>void 0===n[e])).map((e=>t[e])).reduce(((e,t,r,n)=>e.concat(zr(t,"hash"))),[]).concat(r);return zr(i,"hash").sort(Cr.compare)}static findTailHashes(e){const t={};return e.forEach((e=>t[e.hash]=!0)),e.reduce(((e,r,n,o)=>(r.next.reverse().forEach((r=>{void 0===t[r]&&e.splice(0,0,r)})),e)),[])}static difference(e,t){const r=Object.keys(e._headsIndex),n={},o={},i=e=>{n[e]||t.get(e)||(r.push(e),n[e]=!0)};for(;r.length>0;){const s=r.shift(),a=e.get(s);a&&!t.get(s)&&a.id===t.id&&(o[a.hash]=a,n[a.hash]=!0,a.next.concat(a.refs).forEach(i))}return o}}const an=sn})(),Log=n})();